from burp import IBurpExtender, ITab  # To Create Main Class
import sys  # Required for debugging in BurpSuite
from burp import IContextMenuFactory
from burp import IContextMenuInvocation, IHttpService, IParameter, IMessageEditorController, IHttpRequestResponse
from burp import IMessageEditorTabFactory
from burp import IMessageEditorTab
from burp import IBurpExtender
from burp import IMessageEditorTabFactory
from burp import IMessageEditorTab
from java.awt import BorderLayout, FlowLayout
from javax import swing
from java import awt
import java.lang.Short
from javax.swing import JMenuItem
import csv
from java.lang import String, Integer, Comparable
from java.util import ArrayList, List
from javax.swing import ListSelectionModel , KeyStroke
from javax.swing.table import DefaultTableModel, AbstractTableModel , TableColumnModel , DefaultTableColumnModel
from javax.swing import JTable, JButton, JTextField, GroupLayout, JTabbedPane ,JTextArea, JTextPane
from javax.swing import JScrollPane, JSplitPane, JLabel, AbstractAction, JPopupMenu, JComboBox, DefaultCellEditor
from java.awt import Dimension, GridLayout
import javax.swing.BoxLayout
import javax.swing.Box
from javax.swing import JPanel, JFileChooser, AbstractButton
from javax.swing.filechooser import FileNameExtensionFilter
from javax.swing import JFileChooser
from javax.swing import *
from java.awt import * 
from java.awt.event import *   
from javax.swing.event import TableModelListener
#from java.awt.event import MouseAdapter, MouseListener
from threading import Lock
from java.awt.event import ActionListener, KeyEvent
from javax.swing.undo import UndoManager, CompoundEdit
#from javax.swing.event import UndoableEditEvent, DocumentListener
from urlparse import urlparse
import time
import os




# Creating Burp Extend Class
class BurpExtender(IBurpExtender, ITab, IContextMenuFactory, AbstractTableModel, IMessageEditorController, TableColumnModel):
    

    def registerExtenderCallbacks(self, callbacks):
        self.callbacks = callbacks
        self.helpers = callbacks.getHelpers()

        # Allowing debugging
        sys.stdout = callbacks.getStdout()
        sys.stderr = callbacks.getStderr()

        # Informing Burp suite the name of the extension
        callbacks.setExtensionName("Pentest Mapper")

        # Creating a output after loading
        callbacks.printOutput("Author: AnoF")
        callbacks.printOutput("https://github.com/Anof-cyber/Pentest-Mapper")

        callbacks.registerContextMenuFactory(self)
        #callbacks.registerMessageEditorTabFactory(self)
        


        self.tab = swing.JPanel(BorderLayout())
        self.tabbedPane = swing.JTabbedPane()
        self.tab.add("Center", self.tabbedPane)

        self._log = list()
        #self.vulnlist =list()        
        #self.logEntry = list()
        self._lock = Lock()
        #self.checklistlog = list()
        # Creating Another Tab in the extension tab

        # Creating the First tab named as CheckList
        self.firstTab = swing.JPanel()
        self.firstTab.layout = BorderLayout()
        self.tabbedPane.addTab("CheckList", self.firstTab)
        callbacks.addSuiteTab(self)

        # Creating a Import button in CheckList Tab

        self.buttonPanel = swing.JPanel()
        self.buttonPanel.setPreferredSize(Dimension(0, 30))
        # adding the import button with onclick action which refers to the function below
        self.buttonPanel.add(swing.JButton(
            "Import CheckList", actionPerformed=self.importchecklist))
        self.buttonPanel.add(Box.createRigidArea(Dimension(35, 0)))
        self.buttonPanel.add(swing.JButton(
            "Create CheckList", actionPerformed=self.createtestcases))
        self.firstTab.add(self.buttonPanel, BorderLayout.PAGE_START)

        # Creating a tab in CheckList tab which will show the data from the import checlist
        self.tablePanel = swing.JPanel()
        layout = GroupLayout(self.tablePanel)
        self.tablePanel.setLayout(layout)
        self.colNames = ('Sr', 'Test-Cases')
        self.data = [['', ''], ]
        self.dataModel = CustomDefaultTableModelHosts(None, self.colNames)
        self.table = JTable(self.dataModel)
        self.table.getTableHeader().setReorderingAllowed(False)
        self.table.setAutoCreateRowSorter(True)
        self.scrollPane = JScrollPane(self.table)
        X_BASE2 = 200  # send to leff
        # 3rd one send to right
        self.scrollPane.setBounds(X_BASE2 + 100, 40, 1200, 800)
        self.scrollPane.setPreferredSize(Dimension(1500, 500))
        self.scrollPane.getViewport().setView((self.table))
        self.tablePanel.add(self.scrollPane)
        self.firstTab.add(self.tablePanel, BorderLayout.CENTER)

        # Creating Second Tab
        self.secondTab = swing.JPanel()
        self.secondTab.layout = BorderLayout()
        self.tabbedPane.addTab("API Mapper", self.secondTab)


        # creating UI for button and button in api mapper tab
        self.buttonPanel2 = swing.JPanel()
        self.buttonPanel2.setPreferredSize(Dimension(0, 30))

        # adding the import button with onclick action which refers to the function below
        self.buttonPanel2.add(swing.JButton(
            "Save Project", actionPerformed=self.savelogger))
        self.buttonPanel2.add(Box.createRigidArea(Dimension(35, 0)))
        self.buttonPanel2.add(swing.JButton(
            "Load Project", actionPerformed=self.importlogger))
        self.secondTab.add(self.buttonPanel2, BorderLayout.PAGE_START)


        # Creating a UI for table in api mapper tab
        self.tablePanel2 = swing.JPanel((FlowLayout(FlowLayout.LEADING, 50, 50)))
        layout = GroupLayout(self.tablePanel2)
        self.tablePanel2.setLayout(layout)


        # not in use still not removed
        self.colNames2 = ('Sr', 'URL', 'Method', 'Post Body',
                          'Functionality Name', 'Request', 'Test Cases')

        self.data2 = [['', ''], ] # not in use still not removed 
       # self.dataModel2 = JTable(MyTableModel())
        

        '''
        creating a menu which will be added with the table in api mapper for right click 
        also assigning a fumction to handle the event when click
        '''
        popupMenu = JPopupMenu()
        sendVulneraility = JMenuItem("Add to Vulnerabilities", actionPerformed=self.sendVulnItem)
        sendRepeaterItem = JMenuItem("Send request to Repeater", actionPerformed=self.sendRepeaterItem)
        deleterow = JMenuItem("Delete Row", actionPerformed=self.deleterow)
        popupMenu.add(sendVulneraility)
        popupMenu.add(sendRepeaterItem)
        popupMenu.add(deleterow)
        

        # creating a table with custom model for api mapper
        self.logTable = Table(self)
        

        # allowed colum size for api mapper tab/table
        self.logTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF)
        self.logTable.getTableHeader().setReorderingAllowed(False)
        self.logTable.getColumnModel().getColumn(0).setPreferredWidth(100)
        self.logTable.getColumnModel().getColumn(1).setPreferredWidth(600)
        self.logTable.getColumnModel().getColumn(2).setPreferredWidth(100)
        self.logTable.getColumnModel().getColumn(3).setPreferredWidth(800)
        self.logTable.getColumnModel().getColumn(4).setPreferredWidth(300)
        self.logTable.setRowSelectionAllowed(True)

        #adding a right click menu in the table in api mapper
        self.logTable.setComponentPopupMenu(popupMenu)



        # Creating a scroller for table in api mapper and also width hight for table
        self.scrollPane2 = JScrollPane(self.logTable)
        X_BASE3 = 1  # send to leff
        self.scrollPane2.setBounds(X_BASE3 + 10, 20, 1900, 570)  # 3rd one send to right
        self.scrollPane2.setPreferredSize(Dimension(1500, 700))
        self.scrollPane2.getViewport().setView((self.logTable))
        self.tablePanel2.add(self.scrollPane2)


        
        # creating a save test case button and UI and a split pane
        self.CommentsSplitPane = JSplitPane(JSplitPane.VERTICAL_SPLIT);
        self.bottomviewpanel = swing.JPanel()
        self.buttonPanel3 = swing.JPanel(FlowLayout(FlowLayout.LEADING, 10, 10))
        self.buttonPanel3.add(swing.JButton(
            "Save TestCases", actionPerformed=self.SaveTestCases))
        

        #crearting a text box for test cases
        self.testcases = JTextPane()
        self.testcases.setContentType("text/plain");
        self.testcases.setEditable(True)
        penTesterCommentBoxScrollPane = JScrollPane(self.testcases)

        # creating a split in test cases to add button and text box
        self.CommentsSplitPane.setTopComponent(self.buttonPanel3)
        self.CommentsSplitPane.setBottomComponent(penTesterCommentBoxScrollPane);
   
       

        # creating a message editor from burp to show request 
        self.requestViewer = callbacks.createMessageEditor(None, True)
        #self._txtInput = callbacks.createTextEditor()
        #self._txtInput.setEditable(True)
        
       
       #adding the tapped pane to create request and test cases 
        self.editor_view = JTabbedPane()
        self.editor_view.addTab("Request", self.requestViewer.getComponent())
        #self.editor_view.addTab('Test Cases', self._txtInput.getComponent())
        self.editor_view.addTab('Test Cases', self.CommentsSplitPane)

        # self.buttonPanel3.add

        # creating a split in api mapper with split size
        spl = JSplitPane(JSplitPane.VERTICAL_SPLIT)
        spl.setResizeWeight(.7)


        # adding the UI for split pane in api mapper tab

        #spl.setTopComponent(self.tablePanel2)
        #spl.setBottomComponent(self.editor_view) - replaced with left right
        spl.setLeftComponent(self.tablePanel2)
        spl.setRightComponent(self.editor_view)
        #spl.setBottomComponent(editorviews(self)) -replaced with left right

        # adding the spilt part to api mapper tab
        self.secondTab.add(spl)

        # addinf the burp Defalut UI customization for the api mapper tab
        self.callbacks.customizeUiComponent(spl)
        self.callbacks.customizeUiComponent(self.logTable)
        self.callbacks.customizeUiComponent(self.scrollPane2)
        self.callbacks.customizeUiComponent(self.editor_view)


        # creating a new tab 
        self.ThirdTab = swing.JPanel()
        self.ThirdTab.layout = BorderLayout()
        self.tabbedPane.addTab("Vulnerabilities", self.ThirdTab)    


        # creating the button and button location and width in vulnerability tab
        self.buttonPanel4 = swing.JPanel()
        self.buttonPanel4.setPreferredSize(Dimension(0, 30))
        # adding the import button with onclick action which refers to the function below
        self.buttonPanel4.add(swing.JButton(
            "Import Vulnerabilities", actionPerformed=self.importvulnerability))
        self.buttonPanel4.add(Box.createRigidArea(Dimension(35, 0)))
        self.buttonPanel4.add(swing.JButton(
            "Export Vulnerabilities", actionPerformed=self.exportvulnerability))

        # adding the button in vulnerability tab
        self.ThirdTab.add(self.buttonPanel4, BorderLayout.PAGE_START)



        # creating the UI pannel for vulnerability tab --> table
        self.tablePanel3 = swing.JPanel()
        layout = GroupLayout(self.tablePanel3)
        self.tablePanel3.setLayout(layout)


        # Creating a jcombobox that will show the selection option, and adding and none or empty item for selection
        self.comboBox = JComboBox()
        self.comboBox.addItem(None)


        # creating the table to vulnerability tab
        self.colNames3 = ('URL', 'Parameters','Vulnerability')
        self.dataModel2 = CustomDefaultTableModelHosts2(None,self.colNames3)
        self.table3 = JTable(self.dataModel2)
        self.table3.setAutoCreateRowSorter(True)
        self.table3.getColumnModel().getColumn(2).setPreferredWidth(0)
        self.table3.getColumnModel().getColumn(1).setPreferredWidth(0)
        self.table3.getTableHeader().setReorderingAllowed(False)
        comboColumn = self.table3.getColumnModel().getColumn(2)
        comboColumn.setCellEditor(DefaultCellEditor(self.comboBox))



        popupMenu2 = JPopupMenu()
        deletevulnerability = JMenuItem("Delete Vulnerability", actionPerformed=self.deletevuln)
        popupMenu2.add(deletevulnerability)
        self.table3.setComponentPopupMenu(popupMenu2)
        
        

        # adding the table size, width, location and will add the scroller to the table
        self.scrollPane3 = JScrollPane(self.table3)
        X_BASE3 = 1  # send to leff
        # 3rd one send to right
        self.scrollPane3.setBounds(X_BASE3 + 10, 20, 1900, 850)
        self.scrollPane3.setPreferredSize(Dimension(1500, 700))
        self.scrollPane3.getViewport().setView((self.table3))
        self.tablePanel3.add(self.scrollPane3)

        # adding the table UI to vulnerability tab
        self.ThirdTab.add(self.tablePanel3, BorderLayout.CENTER)


      
       


    # this will send the selected row in api mapper to vulnerability tab
    def sendVulnItem(self,event):
        row = self.logTable.getSelectedRows()
        for rows in row:
            logEntry = self._log[rows]
            self.url = logEntry._url
            obj = [str(self.url), None]
            self.dataModel2.addRow(obj)
            
     # function will handle to send the selected row to repeater       
    def sendRepeaterItem(self,event):
        row = self.logTable.getSelectedRows()
              
        for rows in row:
            #self.callbacks.printOutput(str(rows))
            logEntry = self._log[rows]
            fullurl = logEntry._url
            url = urlparse(str(fullurl))
            hostname = url.hostname
            port = url.port
            protocol = url.scheme
            request = self.helpers.stringToBytes(logEntry._requestResponse)
            func = logEntry._FunctionalityName
            if protocol == "https":
                self.callbacks.sendToRepeater(hostname,port, True, request, func)
            else:
                self.callbacks.sendToRepeater(hostname,port, False, request, func)



    # function will handle, delete the row from api mapper
    def deleterow(self,event):

       
        row = self.logTable.getSelectedRows()
        for rows in row:
            #logEntry = self._log[rows]
            self._log.pop(rows)
            self.fireTableDataChanged()
            #totalrow = self.logTable.getRowCount()
            #self.callbacks.printOutput(str(totalrow))       


    def deletevuln(self,e):
        totalvulnrows = self.table3.getSelectedRows()
        #self.callbacks.printOutput(str(totalvulnrows))
        for rows in totalvulnrows:
            #self.callbacks.printOutput(str(rows))
            self.dataModel2.removeRow(rows)
        
    
    
    # part of custom table model to get total number of row in the table, it will check the data in the list amd will return when called     
    def getRowCount(self):
        try:
            return len(self._log)
        except:
            return 0

    # this is required to work with AbstractTableModel, this will show return the total columns in API Mapper
    def getColumnCount(self):
        return 5

    # this is required to work with AbstractTableModel, this will show the columns Name for API Mapper table
    def getColumnName(self, columnIndex):
        if columnIndex == 0:
            return "SR"
        if columnIndex == 1:
            return "URL"
        if columnIndex == 2:
            return "Method"
        if columnIndex == 3:
            return "Post Body"
        if columnIndex == 4:
            return "Functionality Name"
        return ""

    # this is required to work with AbstractTableModel, this will show the data in the columns from the list for API Mapper table
    def getValueAt(self, rowIndex, columnIndex):
        self.totalrow = self.logTable.getRowCount()
        if rowIndex < self.getRowCount() and columnIndex < self.getColumnCount():
       
            logEntry = self._log[rowIndex]
            if columnIndex == 0:
                #return logEntry._sr
                return str(rowIndex + 1)
            if columnIndex == 1:
                return logEntry._url
            if columnIndex == 2:
                return logEntry._method
            if columnIndex == 3:
                return logEntry._postbody
            if columnIndex == 4:
                return logEntry._FunctionalityName
            return ""
        else:
            self.callbacks.printError("Table is empty")

    ''' 
    part of custom table for api mapper, it will get the edited value from function column and will save it in the class based list 
    for the selected row

    '''
    def setValueAt(self, value, rowIndex, columnIndex):

        if rowIndex < self.getRowCount() and columnIndex < self.getColumnCount():
                logEntry = self._log[rowIndex]
                logEntry._FunctionalityName = value
        else:
            self.callbacks.printError("Table is empty")
      
    ''''    
    def getHttpService(self):
        return self._currentlyDisplayedItem.getHttpService()

    def getRequest(self):
        return self._currentlyDisplayedItem.getRequest()

    def getResponse(self):
        return self._currentlyDisplayedItem.getResponse()

    '''
    #function that will show a option to send request to extension in proxy/repeater etc
    def createMenuItems(self, invocation):
        ctx = invocation.getInvocationContext()
        menu = []
        menu.append(swing.JMenuItem("Send To API Mapper", None,actionPerformed=lambda x, inv=invocation: self.getTabledataa(inv)))
        menu.append(swing.JMenuItem("Send To Vulnerability", None,actionPerformed=lambda x, inv=invocation: self.getVulnerabilitydataa(inv)))

        if menu == []:
            return
        else:
            return menu


    # function will be called when user send any request to vulnerabilites tab, it will give the selected message
    def getVulnerabilitydataa(self,invocation):
        reqRes = invocation.getSelectedMessages()
        for items in reqRes:
            self.url = items.getUrl()
            obj = [str(self.url), None]
            self.dataModel2.addRow(obj)



    # function will be called when user send any request to the extension, function will get the required data from the request that is send and will add it to the list
    def getTabledataa(self, invocation):
        reqRes = invocation.getSelectedMessages()
        #requestss = IHttpService()
        for items in reqRes:
            req = self.helpers.analyzeRequest(items)
            self.method = req.getMethod()
            #url = req.url
            paramter = req.getParameters()
            domainame = items.getHost()  # - workings
            portnumer = items.getPort()  # workings
            protocol = items.getProtocol()  # workings
            self.url = items.getUrl()
            gettingrequest = items.getRequest()
            self.requestinst = self.helpers.bytesToString(gettingrequest)
            #requestdetails = req.getRequest()
            getody = req.getBodyOffset()
            self.body = self.requestinst[getody:len(self.requestinst)]


            rowss = self.logTable.getRowCount()
            self.sr2 = str((rowss + 1))
            self._lock.acquire()
            row = len(self._log)
            column = self.logTable.getColumnCount()
            self._log.append(LogEntry(self.sr2, self.url, self.method, self.body, self.requestinst, '', ''))
            self.fireTableRowsInserted(row, row)
            self._lock.release()


     # Returning the tab name to Burp Suite
    def getTabCaption(self):
        return "Pentest Mapper"


    # Returning the UI to the extension tab - Returning the new taB insite the extension tab
    def getUiComponent(self):
        #return self.tab
        return self.tabbedPane

    # function will export the table data when clicked on save button in api mapper tab
    def savelogger(self,e):
        currenttime = str(time.strftime('%Y-%m-%d,%H:%M:%S', time.localtime(time.time())))
        chooseFile = swing.JFileChooser()
        chooseFile.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
        returnedFile = chooseFile.showDialog(self.buttonPanel2, "Output Path")
        
        '''
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)
        returnedFile = chooseFile.showDialog(self.buttonPanel2, "Choose File")
        '''

        

        if returnedFile == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            #self.filepath = fileLoad.getAbsolutePath()
            self.filepath = fileLoad.getPath()
            fname = "APIMapper"+str(time.time())+"."+"csv"
            fnameWithPath = os.path.join(self.filepath,fname)
           
            with open(fnameWithPath, 'wb') as loggerdata:
                writer = csv.writer(loggerdata)
                for logEntry in self._log:
                    
                    self.callbacks.printOutput(str(logEntry._sr))
                    writer.writerow([str(logEntry._sr), str(logEntry._url) ,str(logEntry._method) ,str(logEntry._postbody) ,str(logEntry._FunctionalityName) ,str(logEntry._requestResponse) ,str(logEntry._TestCases)])
            loggerdata.close()


    # function to handle event to import table data in api mapper tab
    def importlogger(self,e):
        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)

        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.filepath = fileLoad.getAbsolutePath()
            with open(self.filepath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                
                for rows in reader2:
                    SR = rows[0]
                    url = rows[1]
                    method = rows[2]
                    body = rows[3]
                    functionname = rows[4]
                    request = rows[5]
                    testcases = rows[6]
                    self._log.append(LogEntry(SR,url, method,body,request,functionname,testcases))
                    #self.fireTableRowsInserted(row, row)
                    self.callbacks.printOutput(str(len(self._log)))
                f.close()
                self.fireTableDataChanged()







    #Function that will be called when user click on import in checklist tab
    def importchecklist(self, e):
        
        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)
        
        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.filepath = fileLoad.getAbsolutePath()
            self.comboBox.removeAllItems()
            self.comboBox.addItem(None)
            self.dataModel.setRowCount(0)
            with open(self.filepath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                #self.data1 = list(reader)
                for rows in reader2:
                    SR = rows[0]
                    title = rows[1]
                    obj = [SR,title]
                    #checklistlog.append(title)
                    #rowsss = self.dataModel.getRowCount()
                    #self.callbacks.printOutput(str(rowsss)) 
                    self.dataModel.addRow(obj)
                    self.comboBox.addItem(str(title))
                f.close()




            

    # creating a function that will be called when user clicks on the create button this function will show the input field in UI for checklist taB
    def createtestcases(self, e):
        self.textfield1 = JTextField('', 15)
        self.buttonPanel.add(self.textfield1)
        self.buttonPanel.add(swing.JButton(
            "Sumit", actionPerformed=self.addrow))
        self.buttonPanel.add(Box.createVerticalGlue())

    # this function will be called as soon as user click on suBmit Button of add row UI input 
    def addrow(self, e):
        rowsss = self.dataModel.getRowCount()
        sr = (rowsss + 1)
        title = self.value = self.textfield1.getText()
        obj = [sr, title]
        #checklistlog.append(title)
        self.comboBox.addItem(str(title))
        #ChecklistLogEntry
        self.dataModel.addRow(obj)

    # function to handel event when save button clicked on test cases 
    def SaveTestCases(self,e):
        selectedrow = self.logTable.getSelectedRow()
        if selectedrow >= 0:
            logEntry = self._log[selectedrow]
            Value = self.testcases.getText()
            logEntry._TestCases = Value


    # function will handle to event once the export button clicked on vulnerablity tab
    def exportvulnerability(self,e):
        totalrow = self.dataModel2.getRowCount()
        self.callbacks.printOutput(str(totalrow))
        
        chooseFile = swing.JFileChooser()

        chooseFile.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
        returnedFile = chooseFile.showDialog(self.buttonPanel4, "Output Path")
        #filter = FileNameExtensionFilter("csv files", ["csv"])
        #chooseFile.addChoosableFileFilter(filter)
        #returnedFile = chooseFile.showDialog(self.buttonPanel4, "Choose File")

        if returnedFile == JFileChooser.APPROVE_OPTION:
            fileLoad1 = chooseFile.getSelectedFile()
            self.filepath2 = fileLoad1.getPath()
            fname2 = "Vulnerability"+str(time.time())+"."+"csv"
            fnameWithPath = os.path.join(self.filepath2,fname2)

            #self.filepath2 = fileLoad1.getAbsolutePath()
            with open(fnameWithPath, 'wb') as vulnerabilitydata:
                writer = csv.writer(vulnerabilitydata)
                for row in range (0, totalrow):
                    url = self.dataModel2.getValueAt(row,0)
                    paramter = self.dataModel2.getValueAt(int(row),1)
                    Vulnerability = self.dataModel2.getValueAt(int(row),2)
                    self.callbacks.printOutput(str(url))
                    
                    #self.callbacks.printOutput(str(logEntry._sr))
                    writer.writerow([str(url), str(paramter) ,str(Vulnerability)])
            vulnerabilitydata.close()



    # function will handle to event once the import button clicked on vulnerablity tab
    def importvulnerability(self,e):
        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)
        
        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.filepath = fileLoad.getAbsolutePath()
            
            #self.dataModel2.setRowCount(0)
            with open(self.filepath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                #self.data1 = list(reader)
                for rows in reader2:
                    URL = rows[0]
                    Parameter = rows[1]
                    Vulnerability = rows[2]
                    obj = [URL,Parameter,Vulnerability]
 
                    self.dataModel2.addRow(obj)
                    
                f.close()




# extending the default table model to remove the editable column from the checklist taB table
class CustomDefaultTableModelHosts(DefaultTableModel):

    # override isCellEditable method
    def isCellEditable(self, row, column):
        return 0


# Extending the default table model for vulnerability tab column 0 (url) is not editable 
class CustomDefaultTableModelHosts2(DefaultTableModel):

    # override isCellEditable method
    def isCellEditable(self, row, column):
        if column == 0:
            return 0
        else:
            return 1





# Extedning the JTable for API Mapper TaB
class Table(JTable):
    def __init__(self, extender):
        self._extender = extender
        self.setModel(extender)
        self.setRowSelectionAllowed(True)
        self.setAutoCreateRowSorter(True)
        
        #self._txtInput = self._extender._txtInput
        
        
        #self.setColumnSelectionAllowed(True)
        
    # Only last colum is allowed for editing    
    def isCellEditable(self, row, column):
        if column == 4:
            return 1
        else:
            return 0
    
    # function that will change the request and test case for selected row
    def changeSelection(self, row, col, toggle, extend):

        # show the log entry for the selected row
        logEntry = self._extender._log[row]
        #self._extender.requestViewer.setMessage(gettingrequest, True)
        self._extender.requestViewer.setMessage(
            logEntry._requestResponse, True)
        text = logEntry._TestCases
        self._extender.testcases.setText(logEntry._TestCases)
        
       
        #self._extender._responseViewer.setMessage(logEntry._requestResponse.getResponse(), False)
        self._extender._currentlyDisplayedItem = logEntry._requestResponse
        JTable.changeSelection(self, row, col, toggle, extend)


#logger entry <- Class based python list to store the data for API Mapper tab/tabble
class LogEntry:
    def __init__(self, sr, url, method, postbody, requestResponse, FunctionalityName, TestCases):
        #self._tool = 'hdh'
        self._sr = sr
        self._url = url
        self._method = method
        self._postbody = postbody
        self._requestResponse = requestResponse
        self._FunctionalityName = FunctionalityName
        self._TestCases = TestCases
