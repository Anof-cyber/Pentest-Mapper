from javax.swing import JTable
from java.lang import Integer, String
from javax.swing.table import AbstractTableModel 


#logger entry <- Class based python list to store the data for API Mapper tab/tabble
class LogEntry:
    def __init__(self, sr, url, method, postbody, requestResponse, FunctionalityName, TestCases, response, status):
        self._sr = sr
        self._url = url
        self._method = method
        self._postbody = postbody
        self._requestResponse = requestResponse
        self._FunctionalityName = FunctionalityName
        self._TestCases = TestCases
        self._response = response
        self._status = status



# Extedning the JTable for API Mapper TaB
class Table(JTable):
    def __init__(self, extender,tablemodel):
        self._extender = extender
        self.setModel(tablemodel)
        self.setRowSelectionAllowed(True)
        self.setAutoCreateRowSorter(True)
        
    def getColumnClass(self, column):
        columnClasses = [Integer, String, String, String, String,String]
        return columnClasses[column]
            
    # Only last colum is allowed for editing    
    def isCellEditable(self, row, column):
        if column == 4 or 5:
            return 1
        else:
            return 0
    
    # function that will change the request and test case for selected row
    def changeSelection(self, row, col, toggle, extend):
        self.modelRowIndex = self.convertRowIndexToModel(row) 
        self._extender._currentlySelectedLogTableRow = self.modelRowIndex
        logEntry = self._extender._log[int(self.modelRowIndex)]
        self._extender.requestViewer.setMessage(
            logEntry._requestResponse, True)
        self._extender.responseViewer.setMessage(
            logEntry._response, True)
        text = logEntry._TestCases
        self._extender.testcases.setText(logEntry._TestCases)
        self._extender._currentlyDisplayedItem = logEntry._requestResponse
        JTable.changeSelection(self, row, col, toggle, extend)






class CustomTableModel(AbstractTableModel):

    def __init__(self, extender):
        self._log = extender._log
        self.callbacks = extender.callbacks
        #self.logTable = extender.logTable

        # part of custom table model to get total number of row in the table, it will check the data in the list amd will return when called     
    def getRowCount(self):
        try:
            return len(self._log)
        except:
            return 0

    # this is required to work with AbstractTableModel, this will show return the total columns in API Mapper
    def getColumnCount(self):
        return 6

    # this is required to work with AbstractTableModel, this will show the columns Name for API Mapper table
    def getColumnName(self, columnIndex):
        if columnIndex == 0:
            return "SR"
        if columnIndex == 1:
            return "URL"
        if columnIndex == 2:
            return "Method"
        if columnIndex == 3:
            return "Post Body"
        if columnIndex == 4:
            return "Functionality Name"
        if columnIndex == 5:
            return "Status"
        return ""

    # this is required to work with AbstractTableModel, this will show the data in the columns from the list for API Mapper table
    def getValueAt(self, rowIndex, columnIndex):
        #self.totalrow = self.logTable.getRowCount()
        if rowIndex < self.getRowCount() and columnIndex < self.getColumnCount():
            logEntry = self._log[rowIndex]
            if columnIndex == 0:
                return str(rowIndex + 1)
            if columnIndex == 1:
                return logEntry._url
            if columnIndex == 2:
                return logEntry._method
            if columnIndex == 3:
                return logEntry._postbody
            if columnIndex == 4:
                return logEntry._FunctionalityName
            if columnIndex == 5:
                return logEntry._status
            return ""
        else:
            self.callbacks.printError("Table is empty")

    ''' 
    part of custom table for api mapper, it will get the edited value from function column and will save it in the class based list 
    for the selected row

    '''
    def setValueAt(self, value, rowIndex, columnIndex):
        
        if rowIndex < self.getRowCount() and columnIndex == 4:
                logEntry = self._log[rowIndex]
                logEntry._FunctionalityName = value

        if rowIndex < self.getRowCount() and columnIndex == 5:
                logEntry = self._log[rowIndex]
                logEntry._status = value


        else:
            self.callbacks.printError("Table is empty")




